#!/bin/bash

shopt -s extglob

# ============================================================================================ #
#: Title           : setx                                                                      #
#: Sypnosis        : setx [OPTION]... [FILE]                                                   #
#: Date Created    : Tue May 31 15:59:31 PHT 2016 / Tue May 31 07:59:31 UTC 2016               #
#: Last Edit       : Sat Sep  3 08:05:45 PHT 2016 / Sat Sep  3 00:05:45 UTC 2016               #
#: License         : Apache-2.0                                                                #
#: Version         : 3.4.0                                                                     #
#: Author          : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : Insert/remove `Debug codes' in a file/script plus more.                   #
#: Options         : -[achptrxX]                                                               #
#: Home Page       : https://github.com/Jetchisel/setx                                         #
#: ExtComm         : cat,ed,file                                                               #
# ============================================================================================ #

# ******************************************************************************************** #
#                                                                                              #
#   Warn and die functions, for exit messages and default status or an optional exit status.   #
#                                                                                              #
# ******************************************************************************************** #

warn() {
  printf '%s\n' "${BASH_SOURCE##*/}: $*"
}

die() {
  local st=$?
  case $2 in
    *[^0-9]*|'') :;;
    *) st=$2;;
  esac

  case $st in
    0) warn "$1" ;;
    *) warn "$1" >&2;;
  esac

  exit "$st"
}

# ******************************************************************************************** #
#                                                                                              #
#          Check for the required app/executable is with in your PATH, exit otherwise.         #
#                                                                                              #
# ******************************************************************************************** #

Missing=()
ExtComm=(cat ed file)
MissingMessage="is either not installed or it is not in your PATH!"
ExitMessage="Please install the following: "

for apps in "${ExtComm[@]}"; do
  if ! type -P "$apps" >/dev/null; then
    printf '%s %s\n' "$apps $MissingMessage" >&2
    Missing+=("$apps")
  fi
done

(( ${#Missing[@]} )) && die "$ExitMessage[${Missing[*]}] exiting now!" 127

# ******************************************************************************************** #
#                                                                                              #
#                                     The help/usage menu.                                     #
#                                                                                              #
# ******************************************************************************************** #

ShowHelp() {
   cat <<EOF

Usage: ${BASH_SOURCE##*/} [OPTION]... [FILE]

Options:
  -h  --help     Show this help.
  -a, --about    Show a brief info about ${BASH_SOURCE##*/}.
  -c, --comment  Add a # in front of a line.
  -r, --remove   Remove all the [keyword] code.
  -x, --xtrace   Add \`set -x' code to the second line by default.
  -X, --Xtrace   Add \`set -x' and a \`PS4' code at the second line. by default.
  -p, --print    Print [keyword] code.
  -t, --trap     Make the execution of the script line by line, defaults to the second line.

Examples:

${BASH_SOURCE##*/} -c FILE              Add a # in front of all lines.
${BASH_SOURCE##*/} -c 1 FILE            Add a # in front of the first line.
${BASH_SOURCE##*/} -c 10,20 FILE        Add a # in front of lines from 10 to 20.
${BASH_SOURCE##*/} -x FILE              Insert \`set -x' at the second line of FILE.
${BASH_SOURCE##*/} -x 5 FILE            Insert \`set -x' at the fifth line of FILE.
${BASH_SOURCE##*/} -x 5,10 FILE         Insert \`set -x' at the fifth line and \`set +x' at the 10th.
${BASH_SOURCE##*/} -x ,10 FILE          Insert \`set +x' at the 10th line of file.
${BASH_SOURCE##*/} -X FILE              Insert \`set -x' and a \`PS4' at the second line of FILE.
${BASH_SOURCE##*/} -X 5 FILE            Insert \`set -x' and a \`PS4' at the fifth line of FILE.
${BASH_SOURCE##*/} -X 5,10 FILE         Insert \`set -x' and a \`PS4' at the fifth line and \`set +x' at the 10th.
${BASH_SOURCE##*/} -t FILE              Insert a trap at the second line of FILE.
${BASH_SOURCE##*/} -t 5 FILE            Insert a trap at the fifth line of FILE.
${BASH_SOURCE##*/} -p [keyword] FILE    Print the [keyword] code if found in FILE.
${BASH_SOURCE##*/} -r [keyword] FILE    Remove all the [keyword] code if found in FILE.

Keywords:

  debug    All the debug codes \`set -x', \`set +x', and the \`trap'.
  comment  All the lines that has been commented by adding a # in front.
  tspace   All the lines that has trailing white space.


Caveat:
  Inserting any code inside the case statement for example will surely
  break its syntax and will add more bugs in the script in question.
EOF
}

# ******************************************************************************************** #
#                                                                                              #
#                        Function to print some info about the script.                         #
#                                                                                              #
# ******************************************************************************************** #

About() {
   cat <<EOF

                           setx

A  bash  shell script  that  insert \`set [+-]x'  and a \`PS4' debug
code or a trap to make the script  execute line by  line by  using
the  return  key.  Shell  script is  more  verbose  when  the code
is added in the script in question. It is quite handy when writing
and testing a shell script.

Copyright [2016] [Jason V. Ferrer] '<jetchisel@opensuse.org>'

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License
EOF
}

# ******************************************************************************************** #
#                                                                                              #
#                                  Initialize the variables.                                   #
#                                                                                              #
# ******************************************************************************************** #

b=$(tput bold)
g=$(tput setaf 2)
reset=$(tput sgr0)
lb=$(tput setaf 6)
rb=$(tput setaf 1; printf '%s' "$b")
setxcode='set -x #_S_E_T_X_#'
commentcode="#(${BASH_SOURCE##*/})#"
endsetxcode='set +x #_E_N_D_S_E_T_X_#'
ps4code='PS4='\''+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'\'' #_P_S_4_#'
trapcode='trap '\''(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND? ")'\'' DEBUG #_T_R_A_P_#'

# ******************************************************************************************** #
#                                                                                              #
#               The empty arrays for the two arguments required in each options.               #
#                                                                                              #
# ******************************************************************************************** #

comment=() trap=() remove=() print=() xtrace=() Xtrace=()

# ******************************************************************************************** #
#                                                                                              #
#           Function to test if both short - and long -- options are given and exit.           #
#                                                                                              #
# ******************************************************************************************** #

ConflictArg() {
  (($# >= 2)) && die "conflicting options specified \`$*'" 1
}

# ******************************************************************************************** #
#                                                                                              #
#               Loop through the command line arguments/options and process it.                #
#                                                                                              #
# ******************************************************************************************** #

while (($#)); do
  while [[ $1 = -?* ]]; do
    case $1 in
      -a|--about)
          die "$(About)"
        ;;
      -c|--comment)
         commentopts+=("$1") && ConflictArg "${commentopts[@]}"
         comment=("${@:2:2}")
         ((!${#comment[@]})) && die "$1 requires an argument!" 1
         shift
         ;;
      -h|--help)
          die "$(ShowHelp)"
         ;;
      -p|--print)
         printopts+=("$1") && ConflictArg "${printopts[@]}"
         print=("${@:2:2}")
         ((!${#print[@]})) && die "$1 requires an argument!" 1
         shift
         ;;
      -t|--trap)
         trapopts+=("$1") && ConflictArg "${trapopts[@]}"
         trap=("${@:2:2}")
         ((!${#trap[@]})) && die "$1 requires an argument!" 1
         shift
         ;;
      -r|--remove)
         removeopts+=("$1") && ConflictArg "${removeopts[@]}"
         remove=("${@:2:2}")
         ((!${#remove[@]})) && die "$1 requires an argument!" 1
         shift
        ;;
      -x|--xtrace)
         xtraceopts+=("$1") && ConflictArg "${xtraceopts[@]}"
         xtrace=("${@:2:2}")
         ((!${#xtrace[@]})) && die "$1 requires an argument!" 1
         shift
        ;;
      -X|--Xtrace)
         Xtraceopts+=("$1") && ConflictArg "${Xtraceopts[@]}"
         Xtrace=("${@:2:2}")
         ((!${#Xtrace[@]})) && die "$1 requires an argument!" 1
         shift
        ;;
       *)
         die "Invalid option \`$*'" 1
       ;;
    esac
  done
  shift
done

# ******************************************************************************************** #
#                                                                                              #
#                        Test if [-x|--xtrace] is given and process it.                        #
#                                                                                              #
# ******************************************************************************************** #

if ((${#xtrace[@]} == 1)); then
  xtraceOneLine=1
  xtraceFiLe=${xtrace[0]}
elif ((${#xtrace[@]} == 2)); then
  [[ ${xtrace[0]} = *[0-9]* ]] || die "Invalid line number ${xtrace[0]}" 1
  if [[ ${xtrace[0]} = +([0-9]) ]]; then
    xtraceOneLine=${xtrace[0]}
  elif [[ ${xtrace[0]} = +([0-9]), ]]; then
    xtraceOneLineStart="${xtrace[0]%,*}"
  elif [[ ${xtrace[0]} = ,+([0-9]) ]]; then
    xtraceOneLineEnd="${xtrace[0]#*,}"
  elif [[ ${xtrace[0]} = +([0-9]),+([0-9]) ]]; then
    xtraceTwoLine=${xtrace[0]}
    xtraceTwoLineStart=${xtrace[0]%,*}
    xtraceTwoLineEnd=${xtrace[0]#*,}
  fi
  xtraceFiLe=${xtrace[1]}
fi

if [[ $xtraceTwoLineEnd && $xtraceTwoLineStart ]]; then
  if [[ $xtraceTwoLineStart -ge $xtraceTwoLineEnd ]]; then
    die "${setxcode%+( )*} before ${endsetxcode%+( )*}" 1
  fi
fi

# ******************************************************************************************** #
#                                                                                              #
#                        Test if [-X|--Xtrace] is given and process it.                        #
#                                                                                              #
# ******************************************************************************************** #

if ((${#Xtrace[@]} == 1)); then
  XtraceOneLine=1
  XtraceFiLe=${Xtrace[0]}
elif ((${#Xtrace[@]} == 2)); then
  [[ ${Xtrace[0]} = *[0-9]* ]] || die "Invalid line number ${Xtrace[0]}" 1
  if [[ ${Xtrace[0]} = +([0-9]) ]]; then
    XtraceOneLine=${Xtrace[0]}
  elif [[ ${Xtrace[0]} = +([0-9]), ]]; then
    XtraceOneLineStart="${Xtrace[0]%,*}"
  elif [[ ${Xtrace[0]} = ,+([0-9]) ]]; then
    XtraceOneLineEnd="${Xtrace[0]#*,}"
  elif [[ ${Xtrace[0]} = +([0-9]),+([0-9]) ]]; then
    XtraceTwoLine=${Xtrace[0]}
    XtraceTwoLineStart=${Xtrace[0]%,*}
    XtraceTwoLineEnd=${Xtrace[0]#*,}
  fi
  XtraceFiLe=${Xtrace[1]}
fi

if [[ $XtraceTwoLineEnd && $XtraceTwoLineStart ]]; then
  if [[ $XtraceTwoLineStart -ge $XtraceTwoLineEnd ]]; then
    die "${setxcode%+( )*} before ${endsetxcode%+( )*}" 1
  fi
fi

# ******************************************************************************************** #
#                                                                                              #
#                         Test if [-t|--trap] is given and process it.                         #
#                                                                                              #
# ******************************************************************************************** #

if ((${#trap[@]} == 1)); then
  trapOneLine=1
  trapFiLe=${trap[0]}
elif ((${#trap[@]} == 2)); then
  [[ ${trap[0]} = +([0-9]) ]] || die "Invalid line number ${trap[0]}" 1
  [[ ${trap[0]} = +([0-9]) ]] && trapOneLine=${trap[0]}
  trapFiLe=${trap[1]}
fi

# ******************************************************************************************** #
#                                                                                              #
#                       Test if [-c|--comment] is given and process it.                        #
#                                                                                              #
# ******************************************************************************************** #

if ((${#comment[@]} == 1)); then
  commentAllLines=1
  commentFiLe=${comment[0]}
elif ((${#comment[@]} == 2)); then
  [[ ${comment[0]} = *[0-9]* ]] || die "Invalid line number ${comment[0]}" 1
  if [[ ${comment[0]} = +([0-9]) ]]; then
    commentOneLine=${comment[0]}
  elif [[ ${comment[0]} = +([0-9]), ]]; then
    commentOneLineStart="${comment[0]%,*}"
  elif [[ ${comment[0]} = ,+([0-9]) ]]; then
    commentOneLineEnd="${comment[0]#*,}"
  elif [[ ${comment[0]} = +([0-9]),+([0-9]) ]]; then
    commentTwoLine=${comment[0]}
    commentTwoLineStart=${comment[0]%,*}
    commentTwoLineEnd=${comment[0]#*,}
  fi
  commentFiLe=${comment[1]}
fi

# ******************************************************************************************** #
#                                                                                              #
#                        Test if [-p|--print] is given and process it.                         #
#                                                                                              #
# ******************************************************************************************** #

if ((${#print[@]})); then
  if ((${#print[@]} < 2)); then
    die "[-p|--print] Needs two argument [keyword] and [file]" 1
  elif ((${#print[@]} == 2)); then
    [[ ${print[0]} != @(cr|tspace|comment|debug) ]] && die "Invalid argument ${print[0]}" 1
    printArg=${print[0]}
    printFiLe=${print[1]}
  fi
fi

# ******************************************************************************************** #
#                                                                                              #
#                       Test if [-r|--remove] is given and process it.                         #
#                                                                                              #
# ******************************************************************************************** #

if ((${#remove[@]})); then
  if ((${#remove[@]} < 2)); then
    die "[-r|--remove] Needs two argument [keyword] and [file]" 1
  elif ((${#remove[@]} == 2)); then
    [[ ${remove[0]} != @(cr|tspace|comment|debug) ]] && die "Invalid argument ${remove[0]}" 1
    RemoveArg=${remove[0]}
    removeFiLe=${remove[1]}
  fi
fi

# ******************************************************************************************** #
#                                                                                              #
#           Test which file is going to be used and assign it to the FiLe variable.            #
#                                                                                              #
# ******************************************************************************************** #

for files in "$commentFiLe" "$trapFiLe" "$printFiLe" "$xtraceFiLe" "$XtraceFiLe" "$removeFiLe"; do
  [[ $files ]] && FiLe=$files
done
[[ ! $FiLe ]] && die "$(ShowHelp)" 1

# ******************************************************************************************** #
#                                                                                              #
#         Do some various if not extensive testing about the file type of the script.          #
#                                                                                              #
# ******************************************************************************************** #

[[ $FiLe = -?* ]] && die "Try ${BASH_SOURCE##*/} ... ./$FiLe to edit $FiLe" 1
FileType=$(file --mime-type -b -- "$FiLe")
File=\`"$FiLe"\'
[[ $FileType = "cannot open $File (No such file or directory)" ]] && die "$FileType" 1
[[ $FileType = "cannot open $File (Permission denied)" ]] && die "$FileType" 1
[[ $FileType = text* ]] || die "$File $FileType" 1

[[ -w $FiLe ]] || die "cannot write to $File (Permission denied)" 1
[[ -r $FiLe ]] || die "cannot read $File (Permissiondenied)" 1


# ******************************************************************************************** #
#                                                                                              #
#    Count the total value of lines the file and save it in a variable, ala `wc -l < file'.    #
#                                                                                              #
# ******************************************************************************************** #

if ! TotalLines=$(ed -s "$FiLe" <<< $'$='); then
  die "Try ${BASH_SOURCE##*/} ... ./$FiLe to edit $File" 1
fi

# ******************************************************************************************** #
#                                                                                              #
#                    Place line numbers before the line in the whole FiLe.                     #
#                                                                                              #
# ******************************************************************************************** #

WholeLineofFiLe() {
  local line n=1
  while IFS= read -u4 -r line; do
    printf "%2d%s\n" "$n" ":$line"
    ((n++))
  done 4< "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#               Save the line with `set -x' in the variable IsetXcode if found.                #
#                                                                                              #
# ******************************************************************************************** #

IsetXcode=$(
  while IFS= read -r line; do
    if [[ ${line#*:} = "$setxcode"* ]]; then
      printf '%s\n' "$line"
    fi
  done < <(WholeLineofFiLe)
)

# ******************************************************************************************** #
#                                                                                              #
#              Save the line with `set +x' in the variable IsetEndcode if found.               #
#                                                                                              #
# ******************************************************************************************** #

IsetEndcode=$(
  while IFS= read -r line; do
    if [[ ${line#*:} = "$endsetxcode"* ]]; then
      printf '%s\n' "$line"
    fi
  done < <(WholeLineofFiLe)
)

# ******************************************************************************************** #
#                                                                                              #
#             Save the line with `trap' code in the variable IstrapCode if found.              #
#                                                                                              #
# ******************************************************************************************** #

IstrapCode=$(
  while IFS= read -r line; do
    if [[ ${line#*:} = "$trapcode"* ]]; then
      printf '%s\n' "$line"
    fi
  done < <(WholeLineofFiLe)
)

# ******************************************************************************************** #
#                                                                                              #
# Function to add `set -x' and `set +x' at the second line or at a specific line if specified. #
#                                                                                              #
# ******************************************************************************************** #

Insertx() {
  local Start End StartLine EndLine

  [[ $xtraceOneLine ]] && Start=$xtraceOneLine StartLine=$Start
  [[ $xtraceOneLineStart ]] && Start=$xtraceOneLineStart StartLine=$Start
  [[ $xtraceOneLineEnd ]] && End=$xtraceOneLineEnd EndLine=$End
  if [[ $xtraceTwoLine ]]; then
    Start=$xtraceTwoLineStart StartLine=$Start
    End=$xtraceTwoLineEnd EndLine=$End
  fi
  [[ $StartLine -gt $TotalLines ]] && die "$StartLine is more than $TotalLines lines of $FiLe" 1
  [[ $EndLine -gt $TotalLines ]] && die "$EndLine is more than $TotalLines lines of $FiLe" 1

  if [[ $StartLine ]]; then
    if [[ $IsetXcode ]]; then
      die "$FiLe has ${setxcode%+( )*} code at line ${IsetXcode%%:*}." 1
    elif [[ $IsetEndcode ]]; then
      if [[ $StartLine -le ${IsetEndcode%%:*} ]]; then
        die "${endsetxcode%+( )*} is at line ${IsetEndcode%:*} which should come after ${setxcode%+( )*}"
      fi
    fi
  fi

  if [[ $EndLine ]]; then
     if [[ $IsetEndcode ]]; then
       die "$FiLe has ${endsetxcode%+( )*} code at line ${IsetEndcode%%:*}" 1
     elif [[ $IsetXcode ]]; then
      if [[ $EndLine -le ${IsetXcode%%:*} ]]; then
        die "${setxcode%+( )*} before ${endsetxcode%+( )*}"
      fi
    fi
  fi

  if [[ $StartLine && $EndLine ]]; then
    if [[ $StartLine -eq 1 ]]; then
      printf '%s\n' H "2i" "$setxcode" . "${EndLine}i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${setxcode%+( )*}$reset at the second line and $rb${endsetxcode%+( )*}$reset at line $EndLine of $FiLe."
    else
      printf '%s\n' H "${StartLine}i" "$setxcode" . "${EndLine}i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${setxcode%+( )*}$reset at line $StartLine and $rb${endsetxcode%+( )*}$reset at line $EndLine of $FiLe."
    fi
  elif [[ $StartLine ]]; then
    if [[ $TotalLines -eq 1 && $StartLine -eq 1 ]]; then
      printf '%s\n' H '$a' "$setxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${setxcode%+( )*}$reset at the last line of $FiLe."
    elif [[ $TotalLines -gt 1 && $StartLine -eq 1 ]]; then
      printf '%s\n' H "2i" "$setxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${setxcode%+( )*}$reset at the second line of $FiLe."
    elif [[ $TotalLines -ge 1 ]]; then
      printf '%s\n' H "${StartLine}i" "$setxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${setxcode%+( )*}$reset at line $StartLine of $FiLe."
    fi
  elif [[ $EndLine ]]; then
    if [[ $TotalLines -eq 1 && $EndLine -eq 1 ]]; then
      printf '%s\n' H '$a' "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${endsetxcode%+( )*}$reset at the last line of $FiLe."
    elif [[ $TotalLines -gt 1 && $EndLine -eq 1 ]]; then
      printf '%s\n' H "2i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${endsetxcode%+( )*}$reset at the second line of $FiLe."
    else
      printf '%s\n' H "${EndLine}i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${endsetxcode%+( )*}$reset at line $EndLine of $FiLe."
    fi
  fi
}

# ******************************************************************************************** #
#                                                                                              #
#    Function to add `set -x', `PS4' and `set +x' at the second line or at a specific line.    #
#                                                                                              #
# ******************************************************************************************** #

InsertX() {
  local SetxCode Start End StartLine EndLine
  SetxCode=("$ps4code" "$setxcode")

  [[ $XtraceOneLine ]] && Start=$XtraceOneLine StartLine=$Start
  [[ $XtraceOneLineStart ]] && Start=$XtraceOneLineStart StartLine=$Start
  [[ $XtraceOneLineEnd ]] && End=$XtraceOneLineEnd EndLine=$End
  if [[ $XtraceTwoLine ]]; then
    Start=$XtraceTwoLineStart StartLine=$Start
    End=$XtraceTwoLineEnd EndLine=$End
  fi
  [[ $StartLine -gt $TotalLines ]] && die "$rb$StartLine$reset is more than $TotalLines lines of $FiLe" 1
  [[ $EndLine -gt $TotalLines ]] && die "$rb$EndLine$reset is more than $TotalLines lines of $FiLe" 1

  if [[ $StartLine ]]; then
    if [[ $IsetXcode ]]; then
      die "$FiLe has $rb${setxcode%+( )*}$reset code at line $rb${IsetXcode%%:*}$reset" 1
    elif [[ $IsetEndcode ]]; then
      if [[ $StartLine -le ${IsetEndcode%%:*} ]]; then
        die "$rb${endsetxcode%+( )*}$reset is at line $rb${IsetEndcode%:*}$reset which should come after $rb${setxcode%+( )*}$reset"
      fi
    fi
  fi

  if [[ $EndLine ]]; then
    if [[ $IsetEndcode ]]; then
      die "$FiLe has $rb${endsetxcode%+( )*}$reset code at line $rb${IsetEndcode%%:*}$reset" 1
    elif [[ $IsetXcode ]]; then
      if [[ $EndLine -le ${IsetXcode%%:*} ]]; then
        die "$rb${setxcode%+( )*}$reset before $rb${endsetxcode%+( )*}.$reset"
      fi
    fi
  fi

  if [[ $StartLine && $EndLine ]]; then
    if [[ $StartLine -eq 1 ]]; then
      printf '%s\n' H "2i" "${SetxCode[@]}" . "${EndLine}i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${SetxCode[*]}$reset at line 2 and $rb$endsetxcode$reset at $rb$EndLine$reset in $FiLe."
    else
      printf '%s\n' H "${StartLine}i" "${SetxCode[@]}" . "${EndLine}i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${ps4code%+( )*}$reset,$rb${setxcode%+( )*}$reset at line $rb$StartLine$reset and $rb${endsetxcode%+( )*}$reset at line $EndLine in $FiLe."
    fi
  elif [[ $StartLine ]]; then
    if [[ $TotalLines -eq 1 && $StartLine -eq 1 ]]; then
      printf '%s\n' H '$a' "${SetxCode[@]}" . w q | ed -s "$FiLe"
      warn "Inserted $rb${ps4code%+( )*}$reset,$rb${setxcode%+( )*}$reset at the last line of $FiLe."
    elif [[ $TotalLines -gt 1 && $StartLine -eq 1 ]]; then
      printf '%s\n' H "2i" "${SetxCode[@]}" . w q | ed -s "$FiLe"
      warn "Inserted $rb${ps4code%+( )*}$reset,$rb${setxcode%+( )*}$reset at the second line of $FiLe."
    elif [[ $TotalLines -ge 1 ]]; then ##&& StartLine > 1)); then
      printf '%s\n' H "${StartLine}i" "${SetxCode[@]}" . w q | ed -s "$FiLe"
      warn "Inserted $rb${ps4code%+( )*}$reset,$rb${setxcode%+( )*}$reset at line $StartLine $FiLe."
    fi
  elif [[ $EndLine ]]; then
    if [[ $TotalLines -eq 1 && $EndLine -eq 1 ]]; then
      printf '%s\n' H '$a' "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${endsetxcode%+( )*}$reset at the last line of $FiLe."
    elif [[ $TotalLines -gt 1 && $EndLine -eq 1 ]]; then
      printf '%s\n' H "2i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${endsetxcode%+( )*}$reset at the second line of $FiLe."
    else
      printf '%s\n' H "${EndLine}i" "$endsetxcode" . w q | ed -s "$FiLe"
      warn "Inserted $rb${endsetxcode%+( )*}$reset at line $EndLine of $FiLe."
    fi
  fi
}

# ******************************************************************************************** #
#                                                                                              #
#  Function to add/insert `trap code' at the second line or at a specific line if specified.   #
#                                                                                              #
# ******************************************************************************************** #

InsertTrap() {
  local StartLine=$trapOneLine
  if [[ $IstrapCode ]]; then
    die "$FiLe has \`${trapcode%+( )*}' at line ${IstrapCode%%:*}." 1
  fi
  if [[ $StartLine ]]; then
    if [[ $StartLine -gt $TotalLines ]]; then
      die "$rb$StartLine$reset is more than $rb$TotalLines$reset line(s) of $FiLe"
    elif [[ $TotalLines -eq 1 && $StartLine -eq 1 ]]; then
      printf '%s\n' H '$a' "$trapcode" . w q | ed -s "$FiLe"
      warn "Inserted \`$rb${trapcode%+( )*}$reset' at the last line of $FiLe."
    elif [[ $TotalLines -gt 1 && $StartLine -eq 1 ]]; then
      printf '%s\n' H "2i" "$trapcode" . w q | ed -s "$FiLe"
      warn "Inserted \`$rb${trapcode%+( )*}$reset' at the second line of $FiLe."
    elif [[ $TotalLines -ge 1 ]]; then
      printf '%s\n' H "${StartLine}i" "$trapcode" . w q | ed -s "$FiLe"
      warn "Inserted \`$rb${trapcode%+( )*}$reset' at line $StartLine of $FiLe."
    fi
  fi
}

# ******************************************************************************************** #
#                                                                                              #
#             Function to comment out a line or lines by prefending a # in front.              #
#                                                                                              #
# ******************************************************************************************** #

Comment() {
  [[ $commentAllLines ]] && StartEndLines=$commentAllLines
  [[ $commentOneLine ]] && Start=$commentOneLine StartLine=$Start
  [[ $commentOneLineStart ]] && Start=$commentOneLineStart StartLine=$Start
  [[ $commentOneLineEnd ]] && End=$commentOneLineEnd EndLine=$End
  if [[ $commentTwoLine ]]; then
    Start=$commentTwoLineStart StartLine=$Start
    End=$commentTwoLineEnd EndLine=$End
  fi

  if [[ $StartLine && $EndLine ]]; then
    if [[ $EndLine -gt $TotalLines && $StartLine -gt $TotalLines ]]; then
      die "$rb$EndLine$reset & $rb$StartLine$reset is more than $rb$TotalLines$reset lines of $FiLe"
    elif [[ $StartLine -gt $TotalLines ]]; then
      die "$rb$StartLine$reset more than $rb$TotalLines$reset lines of $FiLe" 1
    elif [[ $EndLine -gt $TotalLines ]]; then
      die "$rb$EndLine$reset more than $rb$TotalLines$reset lines of $FiLe" 1
    elif [[ $StartLine -ge $EndLine ]]; then
      die "Comment starts at $rb$StartLine$reset must be lower than where it ends at $rb$EndLine$reset" 1
    else
      printf '%s\n' H "${StartLine},${EndLine}s/^/$commentcode/" w q | ed -s "$FiLe"
      warn "Commented lines from $rb$StartLine$reset to $rb$EndLine$reset in $FiLe."
    fi
  elif [[ $StartLine ]]; then
    [[ $StartLine -gt $TotalLines ]] && die "$StartLine is more than $TotalLines lines of $FiLe" 1
    printf '%s\n' H "${StartLine},s/^/$commentcode/" w q | ed -s "$FiLe"
    warn "Line $rb$StartLine$reset has been commented in $FiLe."
  elif [[ $EndLine ]]; then
    [[ $EndLine -gt $TotalLines ]] && die "$EndLine is more than $TotalLines lines of $FiLe" 1
    printf '%s\n' H "${EndLine},s/^/$commentcode/" w q | ed -s "$FiLe"
    warn "Line $rb$EndLine$reset has been commented in $FiLe."
  elif [[ $StartEndLines ]]; then
    printf '%s\n' H ",s/^/$commentcode/" w q | ed -s "$FiLe"
    warn "All lines has been commented in $FiLe"
  fi
}

# ******************************************************************************************** #
#                                                                                              #
#                              Function to show Carriage returns.                              #
#                                                                                              #
# ******************************************************************************************** #

Pcarriage() {
  local IFS line n=1 pcarriage=()
  while IFS= read -r line; do
    if [[ $line = *'\r$' ]]; then
      printf '%s%s\n' "$g$n$reset" "${lb}:$reset${line//'\r$'/${rb}\\r\$${reset}}"
      pcarriage+=("$line")
      ((n++))
    fi
  done < <(ed -s "$FiLe" <<< $'%l')
  if ((!${#pcarriage[@]})); then
    warn "No Carriage return found in $FiLe."
    return 1
  fi
  return 0
}

# ******************************************************************************************** #
#                                                                                              #
#                             Function to delete Carriage returns.                             #
#                                                                                              #
# ******************************************************************************************** #

RemoveCarriage() {
  if Pcarriage >/dev/null; then
    ed -s "$FiLe" <<< $',s/\r$//g\nwq'
    warn "Carriage returns deleted in $FiLe."
    return 0
  fi
  warn "No Carriage return found in $FiLe."
  return 1
}

# ******************************************************************************************** #
#                                                                                              #
#                 Function to print the commented lines that starts with a #.                  #
#                                                                                              #
# ******************************************************************************************** #

Pcomment() {
  local IFS line commentline=()
  while IFS= read -r line; do
    if [[ ${line#*:} = "$commentcode"* ]]; then
      printf '%s\n' "${line//"$commentcode"/$rb$commentcode$reset}"
      commentline+=("$line")
    fi
  done < <(WholeLineofFiLe)

  if ((!${#commentline[@]})); then
    warn "No comment found in $FiLe."
    return 1
  fi
  return 0
}

# ******************************************************************************************** #
#                                                                                              #
#           Function to remove the comments in the commented lines if found in file.           #
#                                                                                              #
# ******************************************************************************************** #

RemoveComment() {
  if Pcomment >/dev/null; then
    printf '%s\n' H ",s/^.*${commentcode}*//" w q | ed -s "$FiLe"
    warn "Comments has be remove in $FiLe."
    return 0
  fi
  warn "No comment found in $FiLe"
  return 1
}

# ******************************************************************************************** #
#                                                                                              #
#                           Function to print trailing white space.                            #
#                                                                                              #
# ******************************************************************************************** #

Ptspace() {
  local line IFS tspaceline=()
  while IFS= read -u4 -r line; do
    if [[ $line = *[[:blank:]] ]]; then
      printf "%s${rb}*${reset}\n" "$line"
      tspaceline+=("$line")
    fi
  done 4< <(WholeLineofFiLe)

  if ((!${#tspaceline[@]})); then
    warn "No trailing white space found in $FiLe."
    return 1
  fi
  return 0
}

# ******************************************************************************************** #
#                                                                                              #
#                      Function to delete trailing white space using ed.                       #
#                                                                                              #
# ******************************************************************************************** #

RemoveTspace() {
  if Ptspace >/dev/null; then
    ed -s "$FiLe" <<< $',s/[[:blank:]]*$//\nw\nq'
    warn "Trailing white space has been remove in $FiLe"
    return 0
  fi
  warn "No trailing white space found in $FiLe"
  return 1
}

# ******************************************************************************************** #
#                                                                                              #
#                         Function to print `debug codes' in the file.                         #
#                                                                                              #
# ******************************************************************************************** #

Pdebug() {
  local line LineNumber OnlyLine Colon
  MatchLine=()
  while read -r line; do
    if [[ "${line#*:}" = @("$setxcode"|"$endsetxcode"|"$ps4code"|"$trapcode")* ]]; then
      OnlyLine=${line#*:}
      LineNumber=${line%%:*}
      Colon=${lb}:${reset}
      printf '%s%s%s\n' "$g$LineNumber$reset" "$Colon" "$rb${OnlyLine%+( )*}$reset"
      MatchLine+=("$line")
    fi
  done < <(WholeLineofFiLe)

  if ((!${#MatchLine[@]})); then
    warn "$FiLe does not contain any debug code!"
    return 1
  fi
  return 0
}

# ******************************************************************************************** #
#                                                                                              #
#                        Function to undo/remove the debug `set-x' code.                       #
#                                                                                              #
# ******************************************************************************************** #

RemoveInsertX() {
   printf '%s\n' H 'g/^set.*-x.*#_S_E_T_X_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#                             Function to remove/delete `set +x'.                              #
#                                                                                              #
# ******************************************************************************************** #

RemoveEndXcode() {
   printf '%s\n' 'g/^set.*+x.*#_E_N_D_S_E_T_X_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#                           Function to undo/remove the `PS4' code.                            #
#                                                                                              #
# ******************************************************************************************** #

RemoveInsertPs4() {
   printf '%s\n' H 'g/^PS4=.*#_P_S_4_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#                            Function to undo/remove the `step-up'.                            #
#                                                                                              #
# ******************************************************************************************** #

RemoveInsertTrap() {
  printf '%s\n' H 'g/^trap.*read.*DEBUG.*#_T_R_A_P_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#            The `$undofile' (-u) is given we undo/remove all the debug/trap code.             #
#                                                                                              #
# ******************************************************************************************** #

RemoveDebug() {
  local line status=()
  while read -r line; do
    [[ ${line#*:} = @("$setxcode"|"$endsetxcode"|"$ps4code"|"$trapcode")* ]] && status+=("$line")
    [[ ${line#*:} = "$trapcode"* ]] && RemoveInsertTrap && warn "$rb${trapcode%+( )*}$reset deleted in file $FiLe at line ${line%%:*}."
    [[ ${line#*:} = "$setxcode"* ]] && RemoveInsertX && warn "$rb${setxcode%+( )*}$reset deleted in file $FiLe at line ${line%%:*}"
    [[ ${line#*:} = "$ps4code"* ]] && RemoveInsertPs4 && warn "$rb${ps4code%+( )*}$reset deleted in file $FiLe at line ${line%%:*}"
    [[ ${line#*:} = "$endsetxcode"* ]]  && RemoveEndXcode && warn "$rb${endsetxcode%+( )*}$reset deleted in file $FiLe at line ${line%%:*}"
  done < <(WholeLineofFiLe)
  ((!${#status[@]})) && die "$removeFiLe does not contain any debug code!" 1
  return 0
}

# ******************************************************************************************** #
#                                                                                              #
#                  Function to parse the arguments if [-r|--remove] is given.                  #
#                                                                                              #
# ******************************************************************************************** #

Remove() {
  case $RemoveArg in
    cr) RemoveCarriage;;
    debug) RemoveDebug;;
    comment) RemoveComment;;
    tspace) RemoveTspace;;
    *) die "Invalid argument \`$RemoveArg'!";;
  esac
}

# ******************************************************************************************** #
#                                                                                              #
#                   Function to parse the argument if [-p|--print] is given.                   #
#                                                                                              #
# ******************************************************************************************** #

Print() {
  case $printArg in
    cr) Pcarriage;;
    comment) Pcomment ;;
    debug) Pdebug ;;
    tspace) Ptspace ;;
    *) die "Invalid argument \`$printArg'!";;
  esac
}

# ******************************************************************************************** #
#                                                                                              #
#                   Test which file is given and execute the right commands.                   #
#                                                                                              #
# ******************************************************************************************** #

if [[ $XtraceFiLe ]]; then
  InsertX
elif [[ $xtraceFiLe ]]; then
  Insertx
elif [[ $commentFiLe ]]; then
  Comment
elif [[ $trapFiLe ]]; then
 InsertTrap
elif [[ $printFiLe ]]; then
  Print
elif [[ $removeFiLe ]]; then
  Remove
fi

# ============================================================================================ #
#                                                                                              #
#                                   >>> END OF SCRIPT <<<                                      #
#                                                                                              #
# ============================================================================================ #
