#!/usr/bin/env bash

shopt -s extglob

# ============================================================================================ #
#: Title           : setx                                                                      #
#: Sypnosis        : setx [OPTION]... [FILE]                                                   #
#: Date Created    : Tue May 31 15:59:31 PHT 2016 / Tue May 31 07:59:31 UTC 2016               #
#: Last Edit       : Tue Jun 28 12:51:49 PHT 2016 / Tue Jun 28 04:51:49 UTC 2016               #
#: License         : Apache-2.0                                                                #
#: Version         : 2.0.0                                                                     #
#: Author          : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : Insert/Add `Debug codes' in a file/script.                                #
#: Options         : -[abehpsuxX]                                                              #
#: Home Page       : https://github.com/Jetchisel/setx                                         #
#: ExtComm         : cat,ed,file,grep                                                          #
# ============================================================================================ #

# ******************************************************************************************** #
#                                                                                              #
#   Warn and die functions, for exit messages and default status or an optional exit status.   #
#                                                                                              #
# ******************************************************************************************** #

warn() {
  printf '%s\n' "${BASH_SOURCE##*/}: $*"
}

die() {
  local st=$?
  case $2 in
    *[^0-9]*|'') :;;
    *) st=$2;;
  esac

  case $st in
    0) warn "$1" ;;
    *) warn "$1" >&2;;
  esac

  exit "$st"
}

# ******************************************************************************************** #
#                                                                                              #
#          Check for the required app/executable is with in your PATH, exit otherwise.         #
#                                                                                              #
# ******************************************************************************************** #

Missing=()
ExtComm=(ed file)
MissingMessage="is either not installed or it is not in your PATH!"
ExitMessage="Please install the following: "

for apps in "${ExtComm[@]}"; do
  if ! type -P "$apps" >/dev/null; then
    printf '%s %s\n' "$apps" "$MissingMessage" >&2
    Missing+=("$apps")
  fi
done

(( ${#Missing[@]} )) && die "$ExitMessage[${Missing[*]}] exiting now!" 127

# ******************************************************************************************** #
#                                                                                              #
#                                     The help/usage menu.                                     #
#                                                                                              #
# ******************************************************************************************** #

ShowHelp() {
   cat <<EOF
Usage: ${BASH_SOURCE##*/} [OPTION]... [FILE]

Options:
  -h    Show this help.
  -a    Show a brief info about ${BASH_SOURCE##*/}.
  -b    Insert \`set -x' or with a \`PS4' at a specific line, requires numeric argument
  -e    Insert \`set +x' in a specific line, requires a numeric argument.
  -u    Remove all the \`debug' code, requires a file as an argument.
  -x    Add \`set -x' code to the second line by default, requires a file as an argument.
  -X    Add \`set -x' and a \`PS4' code at the second line. by default, requires a file
        as an argument.
  -p    Print all the \`debug' codes from file.
  -s    Make the execution of the script line by line, defaults to the second line.
        Requires a file as an argument.

Examples:

${BASH_SOURCE##*/} -x FILE              Insert \`set -x' at the second line of FILE.
${BASH_SOURCE##*/} -x FILE -b 5         Insert \`set -x' at the fifth line of FILE.
${BASH_SOURCE##*/} -x FILE -b 5 -e 10   Insert \`set -x' at the fifth line and \`set +x' at the 10th.
${BASH_SOURCE##*/} -X FILE              Insert \`set -x' and a \`PS4' at the second line of FILE.
${BASH_SOURCE##*/} -X FILE -b 5         Insert \`set -x' and a \`PS4' at the fifth line of FILE.
${BASH_SOURCE##*/} -X FILE -b 5 -e 10   Insert \`set -x' and a \`PS4' at the fifth line and \`set +x'
                                        at the 10th.
${BASH_SOURCE##*/} -s FILE              Insert a trap at the second line of FILE.
${BASH_SOURCE##*/} -s FILE -b 5         Insert a trap at the fifth line of FILE.
${BASH_SOURCE##*/} -p FILE              Print the debug codes if found in FILE.
${BASH_SOURCE##*/} -u FILE              Remove all the debug code in FILE.
EOF
}

# ******************************************************************************************** #
#                                                                                              #
#                     Show the help/usage if no option/arguments is given.                     #
#                                                                                              #
# ******************************************************************************************** #

((!$#)) && die "$(ShowHelp)" 1

[[ $1 = '-' ]] && die "$(ShowHelp)" 1

# ******************************************************************************************** #
#                                                                                              #
#                        Function to print some info about the script.                         #
#                                                                                              #
# ******************************************************************************************** #

About() {
   cat <<EOF

                           setx

A bash  shell  script  that  inserts \`set -x' and a \`PS4' debug
code or a trap to make the script execute line by line by using
the  return  key.  Shell  script is  more verbose when the code
is  added in the script in question.

Copyright [2016] [Jason V. Ferrer] '<jetchisel@opensuse.org>'

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License
EOF
}

# ******************************************************************************************** #
#                                                                                              #
#                                  Initialize the variables.                                   #
#                                                                                              #
# ******************************************************************************************** #

end=
help=
about=
begin=
xfile=
Xfile=
undofile=
stepfile=
printfile=
setxcode='set -x #_S_E_T_X_#'
endsetxcode='set +x #_E_N_D_S_E_T_X_#'
ps4code='PS4='\''+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'\'' #_P_S_4_#'
stepcode='trap '\''(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND? ")'\'' DEBUG #_T_R_A_P_#'

# ******************************************************************************************** #
#                                                                                              #
#                Loop through the command line options/arguments using getopts.                #
#                                                                                              #
# ******************************************************************************************** #

while getopts :b:e:p:s:u:x:X:ah opt; do
  case $opt in
    a) about=1
       ;;
    b) begin=$OPTARG
       ;;
    e) end=$OPTARG
       ;;
    h) help=1
       ;;
    p) printfile=$OPTARG
       ;;
    s) stepfile=$OPTARG
       ;;
    u) undofile=$OPTARG
       ;;
    x) xfile=$OPTARG
       ;;
    X) Xfile=$OPTARG
       ;;
    :) die "Option -$OPTARG requires an argument." 1
       ;;
    *) die "Unknown options -$OPTARG" 1
       ;;
  esac
done
shift $((OPTIND-1))

# ******************************************************************************************** #
#                                                                                              #
#    Test for a mix up of -[ah] and -a with -[behpsuxX] or -h with -[behpsuxX] or run -[ah].   #
#                                                                                              #
# ******************************************************************************************** #

if [[  "$about" && "$help" ]]; then
  die "conflicting options specified!" 1
fi
if [[ 1 = @("$about"|"$help") ]]; then
  [[ $begin$end$undofile$printfile$stepfile$xfile$Xfile ]] && die "conflicting options specified!" 1
fi

[[ 1 = "$about" ]] && die "$(About)" 0
[[ 1 = "$help" ]] && die "$(ShowHelp)" 0

# ******************************************************************************************** #
#                                                                                              #
#    Test if no input matching the non optional options -[xpsuxX] then exit with an error.     #
#                                                                                              #
# ******************************************************************************************** #

[[ $xfile$undofile$stepfile$Xfile$printfile ]] || die "-[xpsuX] is not specified." 2

# ******************************************************************************************** #
#                                                                                              #
#            Test for invalid mixture of options/arguments and exit with an error.             #
#                                                                                              #
# ******************************************************************************************** #

[[ $stepfile && $undofile ]] && die "conflicting options specified!" 1
if [[ $undofile ]]; then
 [[ $begin || $end ]] && die "conflicting options specified!" 1
fi
if [[ $stepfile && $end ]]; then
  die "conflicting options specified!" 1
fi

# ******************************************************************************************** #
#                                                                                              #
#         Test for the value of `$begin' and `$end' if not numeric exit with an error.         #
#                                                                                              #
# ******************************************************************************************** #

if [[ $begin ]]; then
  [[ $begin = +([0-9]) ]] || die "$begin is not numeric!" 1
fi
if [[ $end ]]; then
  [[  $end = +([0-9]) ]] || die "$end is not numberic!" 1
fi

# ******************************************************************************************** #
#                                                                                              #
#  If the value of `$end' is greater than `$begin' exit with an error. (set -x before set +x)  #
#                                                                                              #
# ******************************************************************************************** #

if ((begin)); then
  if ((end)); then
    ((begin>=end)) && die "${endsetxcode%+( )*} must be placed after ${setxcode%+( )*}!" 1
  fi
fi

# ******************************************************************************************** #
#                                                                                              #
#  Test which variable file is not empty, assign it to the variable FiLe to be process later.  #
#                                                                                              #
# ******************************************************************************************** #


for usefile in "$xfile" "$Xfile" "$undofile" "$stepfile" "$printfile"; do
  [[ $usefile ]] && FiLe=$usefile
done

# ******************************************************************************************** #
#                                                                                              #
#   Function to do some various if not extensive testing about the file type of the script.    #
#                                                                                              #
# ******************************************************************************************** #

[[ $FiLe = -* ]] && die "Try ${BASH_SOURCE##*/} ... ./$FiLe to edit $FiLe" 1
FileType=$(file --mime-type -b -- "$FiLe")
File=\`"$FiLe"\'
[[ $FileType = "cannot open $File (No such file or directory)" ]] && die "$FileType" 1
[[ $FileType = "cannot open $File (Permission denied)" ]] && die "$FileType" 1
[[ $FileType = text* ]] || die "$File $FileType" 1

[[ -w $FiLe ]] || die "cannot write to $File (Permission denied)" 1
[[ -r $FiLe ]] || die "cannot read $File (Permissiondenied)" 1

# ******************************************************************************************** #
#                                                                                              #
#    Count the total value of lines the file and save it in a variable, ala `wc -l < file'.    #
#                                                                                              #
# ******************************************************************************************** #

if ! TotalLines=$(ed -s "$FiLe" <<< $'$='); then
  die "Try ${BASH_SOURCE##*/} ... ./$FiLe to edit $File" 1
fi

# ******************************************************************************************** #
#                                                                                              #
#  Print colored `debug codes' with a leading number if found, otherwise exit with an error.   #
#                                                                                              #
# ******************************************************************************************** #

if [[ $printfile ]]; then
  if ! grep --color=auto -Fnxwe "$setxcode" -Fnxwe "$stepcode" -Fnwxe "$ps4code" -Fnwxe "$endsetxcode" "$FiLe"; then
    die "$FiLe does not contain any debug code!"
  fi
fi

# ******************************************************************************************** #
#                                                                                              #
#     Function to add ONLY `set -x' at the second line or at a specific line if specified.     #
#                                                                                              #
# ******************************************************************************************** #

Insertx() {
  local LineNumber=$begin Xcode xcode


  if Xcode=$(grep -Fwxne "$setxcode" "$FiLe"); then
    die "$FiLe has set -x code at line ${Xcode%%:*}" 1
  fi
  if ((LineNumber)); then
    if xcode=$(grep -Fwxne "$endsetxcode" "$FiLe"); then
      if (( LineNumber >= ${xcode%%:*} )); then
        die "${endsetxcode%+( )*} is at line ${xcode%:*} which should come after ${setxcode%+( )*}"
      fi
    fi
  fi

  if ((LineNumber)); then
    if ((LineNumber > TotalLines)); then
      die "$LineNumber is more than $TotalLines line(s) of $FiLe"
    fi
    if ((TotalLines == 1 || LineNumber == 1)); then
      printf '%s\n' H '$a' "$setxcode" . w q | ed -s "$FiLe"
    elif (( LineNumber > 1 )); then
      printf '%s\n' H "${LineNumber}i" "$setxcode" . w q | ed -s "$FiLe"
    fi
  else
    if ((TotalLines == 1)); then
      printf '%s\n' H '$a' "$setxcode" . w q | ed -s "$FiLe"
    else
      printf '%s\n' H "2i" "$setxcode" . w q | ed -s "$FiLe"
    fi
  fi
}

# ******************************************************************************************** #
#                                                                                              #
# Function to add `set -x' and a `PS4' code at the second line or at a specific line if given. #
#                                                                                              #
# ******************************************************************************************** #

InsertX() {
  local SetxCode LineNumber=$begin Xcode xcode
  SetxCode=("$ps4code" "$setxcode")

  if Xcode=$(grep -Fnwxe "$setxcode" "$FiLe"); then
    if xcode=$(grep -Fnwxe "$ps4code" "$FiLe"); then
      die "$FiLe has PS4 code at line ${Xcode%%:*} and set -x code at line ${xcode%%:*}!" 1
    else
      die "$FiLe has \`${setxcode%+( )*}' at line ${Xcode%%:*}" 1
    fi
  fi
  if ((LineNumber)); then
    if xcode=$(grep -Fnwxe "$endsetxcode" "$FiLe"); then
      if (( LineNumber >= ${xcode%%:*} )); then
        die "${endsetxcode%+( )*} is at line ${xcode%:*} which should come after ${setxcode%+( )*}"
      fi
    fi
  fi
  if ((LineNumber)); then
    if ((LineNumber > TotalLines)); then
      die "$LineNumber is more than $TotalLines line(s) of $FiLe"
    fi
    if ((TotalLines == 1 || LineNumber == 1)); then
      printf '%s\n' H '$a' "${SetxCode[@]}" . w q | ed -s "$FiLe"
    elif (( LineNumber > 1 )); then
      printf '%s\n' H "${LineNumber}i" "${SetxCode[@]}" . w q | ed -s "$FiLe"
    fi
  else
    if ((TotalLines == 1)); then
      printf '%s\n' H '$a' "${SetxCode[@]}" . w q | ed -s "$FiLe"
    else
      printf '%s\n' H "2i" "${SetxCode[@]}" . w q | ed -s "$FiLe"
    fi
  fi
}

# ******************************************************************************************** #
#                                                                                              #
#    Function to add/insert `set +x' at the second line or at a specific line if specified.    #
#                                                                                              #
# ******************************************************************************************** #

InsertEndXcode() {
  local LineNumber=$end Xcode xcode
  if Xcode=$(grep -Fnwxe "$endsetxcode" "$FiLe"); then
    die "$File has \`${endsetxcode%+( )*}' at line ${Xcode%%:*}."
  fi
  if ((LineNumber)); then
    if xcode=$(grep -Fnwxe "$setxcode" "$FiLe"); then
      if (( LineNumber <= ${xcode%%:*} )); then
        die "${setxcode%+( )*} is in line ${xcode%:*} which should come first before ${endsetxcode%+( )*}!"
      fi
    fi
  fi
  if ((LineNumber)); then
    ((LineNumber > TotalLines)) && die "$LineNumber is more than $TotalLines line(s) of $FiLe"
    if ((TotalLines == 1 || LineNumber == 1)); then
      printf '%s\n' H '$a' "$endsetxcode" . w q | ed -s "$FiLe"
    else
      printf '%s\n' H "${LineNumber}i" "$endsetxcode" . w q | ed -s "$FiLe"
    fi
  fi
}

# ******************************************************************************************** #
#                                                                                              #
# Function to add/insert `step-up' code at the second line or at a specific line if specified. #
#                                                                                              #
# ******************************************************************************************** #

InsertStep() {
  local LineNumber=$begin Xcode
  if Xcode=$(grep -Fnwxe "$stepcode" "$FiLe"); then
    die "$FiLe has \`${stepcode%+( )*}' at line ${Xcode%%:*}." 1
  fi
  if ((LineNumber)); then
    if ((LineNumber > TotalLines)); then
     die "$LineNumber is more than $TotalLines line(s) of $FiLe"
    fi
    if ((TotalLines == 1 || LineNumber == 1)); then
      printf '%s\n' H '$a' "$stepcode" . w q | ed -s "$FiLe"
    elif (( LineNumber > 1 )); then
      printf '%s\n' H "${LineNumber}i" "$stepcode" . w q | ed -s "$FiLe"
    fi
  else
    if ((TotalLines == 1)); then
      printf '%s\n' H '$a' "$stepcode" . w q | ed -s "$FiLe"
    else
      printf '%s\n' H "2i" "$stepcode" . w q | ed -s "$FiLe"
    fi
  fi
}

# ******************************************************************************************** #
#                                                                                              #
#                        Function to undo/remove the debug `set-x' code.                       #
#                                                                                              #
# ******************************************************************************************** #

UndoInsertX() {
  printf '%s\n' H 'g/^set.*-x.*#_S_E_T_X_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#                             Function to remove/delete `set +x'.                              #
#                                                                                              #
# ******************************************************************************************** #

UndoEndXcode() {
  printf '%s\n' 'g/^set.*+x.*#_E_N_D_S_E_T_X_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#                           Function to undo/remove the `PS4' code.                            #
#                                                                                              #
# ******************************************************************************************** #

UndoInsertPs4() {
  printf '%s\n' H 'g/^PS4=.*#_P_S_4_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#                            Function to undo/remove the `step-up'.                            #
#                                                                                              #
# ******************************************************************************************** #

UndoInsertStep() {
  printf '%s\n' H 'g/^trap.*read.*DEBUG.*#_T_R_A_P_#$/d' w q | ed -s "$FiLe"
}

# ******************************************************************************************** #
#                                                                                              #
#  If `$xfile' has a value the (-x option) we add `set -x' or both `set -x and `set +x' code.  #
#                                                                                              #
# ******************************************************************************************** #

if [[ $xfile && $begin && $end ]]; then
  Insertx && InsertEndXcode
  die "Added \`${setxcode%+( )*}' at line $begin and \`${endsetxcode%+( )*}' at line $end in file $xfile."
elif [[ $xfile && $end ]]; then
  InsertEndXcode && die "Added \`${endsetxcode%+( )*}' at line $end in file $xfile."
elif [[ $xfile && $begin ]]; then
  Insertx && die "Added \`${setxcode%+( )*}' at line $begin in file $xfile"
elif [[ $xfile ]]; then
  Insertx && die "Added \`${setxcode%+( )*}' at the second line of $xfile"
fi

# ******************************************************************************************** #
#                                                                                              #
#   If `$Xfile' has a value (-X option) we add `set -x, ps4' or together with `set +x' code.   #
#                                                                                              #
# ******************************************************************************************** #

if [[ $Xfile && $begin && $end ]]; then
  InsertX && InsertEndXcode
  die "Added PS4 at line $begin and \`${setxcode%+( )*}' at line $((begin+1)) and \`${endsetxcode%+( )*}' at line $end of $Xfile."
elif [[ $Xfile && $end ]]; then
  InsertEndXcode && die "Added \`${endsetxcode%+( )*}' at line $end in file $Xfile."
elif [[ $Xfile && $begin ]]; then
  InsertX && die "Added \`PS4' at line $begin and \`${setxcode%+( )*}' line $((begin+1))' in file $Xfile."
elif [[ $Xfile ]]; then
  InsertX && die "Added \`PS4' at the second line and \`${setxcode%+( )*}' at the third line in file $Xfile."
fi

# ******************************************************************************************** #
#                                                                                              #
# The `$stepfile' (-s) is given, add the debug trap at the second line or at a specified line. #
#                                                                                              #
# ******************************************************************************************** #

if [[ $stepfile ]]; then
 if [[ $begin ]]; then
   InsertStep && die "Added a \`trap' at line $begin of $stepfile."
 else
   InsertStep && die "Added \`trap' at the second line of $stepfile."
 fi
fi

# ******************************************************************************************** #
#                                                                                              #
#            The `$undofile' (-u) is given we undo/remove all the debug/trap code.             #
#                                                                                              #
# ******************************************************************************************** #

if [[ $undofile ]]; then
  for i in "$setxcode" "$ps4code" "$stepcode" "$endsetxcode"; do
    val=$(grep -Fnwxe "$i" "$undofile") && status+=("$val")
    [[ ${val#*:} = "$stepcode" ]] && UndoInsertStep && warn "$stepcode deleted in file $FiLe at line ${val%%:*}"
    [[ ${val#*:} = "$setxcode" ]] && UndoInsertX && warn "$setxcode deleted in file $FiLe at line ${val%%:*}"
    [[ ${val#*:} = "$ps4code" ]] && UndoInsertPs4 && warn "$ps4code deleted in file $FiLe at line ${val%%:*}"
    [[ ${val#*:} = "$endsetxcode" ]] && UndoEndXcode && warn "$endsetxcode deleted in file $FiLe at line ${val%%:*}"
  done
  ((!${#status[@]})) && die "$undofile does not contain any debug code!" 1
fi

# ============================================================================================ #
#                                                                                              #
#                                   >>> END OF SCRIPT <<<                                      #
#                                                                                              #
# ============================================================================================ #
